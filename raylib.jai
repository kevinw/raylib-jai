//
// AUTOGENERATED
//

LIGHTGRAY :: Color.{  200, 200, 200, 255  };
GRAY :: Color.{  130, 130, 130, 255  };
DARKGRAY :: Color.{  80, 80, 80, 255  };
YELLOW :: Color.{  253, 249, 0, 255  };
GOLD :: Color.{  255, 203, 0, 255  };
ORANGE :: Color.{  255, 161, 0, 255  };
PINK :: Color.{  255, 109, 194, 255  };
RED :: Color.{  230, 41, 55, 255  };
MAROON :: Color.{  190, 33, 55, 255  };
GREEN :: Color.{  0, 228, 48, 255  };
LIME :: Color.{  0, 158, 47, 255  };
DARKGREEN :: Color.{  0, 117, 44, 255  };
SKYBLUE :: Color.{  102, 191, 255, 255  };
BLUE :: Color.{  0, 121, 241, 255  };
DARKBLUE :: Color.{  0, 82, 172, 255  };
PURPLE :: Color.{  200, 122, 255, 255  };
VIOLET :: Color.{  135, 60, 190, 255  };
DARKPURPLE :: Color.{  112, 31, 126, 255  };
BEIGE :: Color.{  211, 176, 131, 255  };
BROWN :: Color.{  127, 106, 79, 255  };
DARKBROWN :: Color.{  76, 63, 47, 255  };
WHITE :: Color.{  255, 255, 255, 255  };
BLACK :: Color.{  0, 0, 0, 255  };
BLANK :: Color.{  0, 0, 0, 0  };
MAGENTA :: Color.{  255, 0, 255, 255  };
RAYWHITE :: Color.{  245, 245, 245, 255  };

TraceLogCallback :: #type (logType: s32, text: *u8, args: ..*u8);

ConfigFlags :: enum_flags {
    FLAG_VSYNC_HINT         :: 0x00000040;   // Set to try enabling V-Sync on GPU
    FLAG_FULLSCREEN_MODE    :: 0x00000002;   // Set to run program in fullscreen
    FLAG_WINDOW_RESIZABLE   :: 0x00000004;   // Set to allow resizable window
    FLAG_WINDOW_UNDECORATED :: 0x00000008;   // Set to disable window decoration (frame and buttons)
    FLAG_WINDOW_HIDDEN      :: 0x00000080;   // Set to hide window
    FLAG_WINDOW_MINIMIZED   :: 0x00000200;   // Set to minimize window (iconify)
    FLAG_WINDOW_MAXIMIZED   :: 0x00000400;   // Set to maximize window (expanded to monitor)
    FLAG_WINDOW_UNFOCUSED   :: 0x00000800;   // Set to window non focused
    FLAG_WINDOW_TOPMOST     :: 0x00001000;   // Set to window always on top
    FLAG_WINDOW_ALWAYS_RUN  :: 0x00000100;   // Set to allow windows running while minimized
    FLAG_WINDOW_TRANSPARENT :: 0x00000010;   // Set to allow transparent framebuffer
    FLAG_WINDOW_HIGHDPI     :: 0x00002000;   // Set to support HighDPI
    FLAG_MSAA_4X_HINT       :: 0x00000020;   // Set to try enabling MSAA 4X
    FLAG_INTERLACED_HINT    :: 0x00010000;
}

TraceLogLevel :: enum {
    LOG_ALL :: 0;        // Display all logs
    LOG_TRACE;
    LOG_DEBUG;
    LOG_INFO;
    LOG_WARNING;
    LOG_ERROR;
    LOG_FATAL;
    LOG_NONE;
}

KeyboardKey :: enum {
    KEY_NULL            :: 0;
    // Alphanumeric keys
    KEY_APOSTROPHE      :: 39;
    KEY_COMMA           :: 44;
    KEY_MINUS           :: 45;
    KEY_PERIOD          :: 46;
    KEY_SLASH           :: 47;
    KEY_ZERO            :: 48;
    KEY_ONE             :: 49;
    KEY_TWO             :: 50;
    KEY_THREE           :: 51;
    KEY_FOUR            :: 52;
    KEY_FIVE            :: 53;
    KEY_SIX             :: 54;
    KEY_SEVEN           :: 55;
    KEY_EIGHT           :: 56;
    KEY_NINE            :: 57;
    KEY_SEMICOLON       :: 59;
    KEY_EQUAL           :: 61;
    KEY_A               :: 65;
    KEY_B               :: 66;
    KEY_C               :: 67;
    KEY_D               :: 68;
    KEY_E               :: 69;
    KEY_F               :: 70;
    KEY_G               :: 71;
    KEY_H               :: 72;
    KEY_I               :: 73;
    KEY_J               :: 74;
    KEY_K               :: 75;
    KEY_L               :: 76;
    KEY_M               :: 77;
    KEY_N               :: 78;
    KEY_O               :: 79;
    KEY_P               :: 80;
    KEY_Q               :: 81;
    KEY_R               :: 82;
    KEY_S               :: 83;
    KEY_T               :: 84;
    KEY_U               :: 85;
    KEY_V               :: 86;
    KEY_W               :: 87;
    KEY_X               :: 88;
    KEY_Y               :: 89;
    KEY_Z               :: 90;

    // Function keys
    KEY_SPACE           :: 32;
    KEY_ESCAPE          :: 256;
    KEY_ENTER           :: 257;
    KEY_TAB             :: 258;
    KEY_BACKSPACE       :: 259;
    KEY_INSERT          :: 260;
    KEY_DELETE          :: 261;
    KEY_RIGHT           :: 262;
    KEY_LEFT            :: 263;
    KEY_DOWN            :: 264;
    KEY_UP              :: 265;
    KEY_PAGE_UP         :: 266;
    KEY_PAGE_DOWN       :: 267;
    KEY_HOME            :: 268;
    KEY_END             :: 269;
    KEY_CAPS_LOCK       :: 280;
    KEY_SCROLL_LOCK     :: 281;
    KEY_NUM_LOCK        :: 282;
    KEY_PRINT_SCREEN    :: 283;
    KEY_PAUSE           :: 284;
    KEY_F1              :: 290;
    KEY_F2              :: 291;
    KEY_F3              :: 292;
    KEY_F4              :: 293;
    KEY_F5              :: 294;
    KEY_F6              :: 295;
    KEY_F7              :: 296;
    KEY_F8              :: 297;
    KEY_F9              :: 298;
    KEY_F10             :: 299;
    KEY_F11             :: 300;
    KEY_F12             :: 301;
    KEY_LEFT_SHIFT      :: 340;
    KEY_LEFT_CONTROL    :: 341;
    KEY_LEFT_ALT        :: 342;
    KEY_LEFT_SUPER      :: 343;
    KEY_RIGHT_SHIFT     :: 344;
    KEY_RIGHT_CONTROL   :: 345;
    KEY_RIGHT_ALT       :: 346;
    KEY_RIGHT_SUPER     :: 347;
    KEY_KB_MENU         :: 348;
    KEY_LEFT_BRACKET    :: 91;
    KEY_BACKSLASH       :: 92;
    KEY_RIGHT_BRACKET   :: 93;
    KEY_GRAVE           :: 96;

    // Keypad keys
    KEY_KP_0            :: 320;
    KEY_KP_1            :: 321;
    KEY_KP_2            :: 322;
    KEY_KP_3            :: 323;
    KEY_KP_4            :: 324;
    KEY_KP_5            :: 325;
    KEY_KP_6            :: 326;
    KEY_KP_7            :: 327;
    KEY_KP_8            :: 328;
    KEY_KP_9            :: 329;
    KEY_KP_DECIMAL      :: 330;
    KEY_KP_DIVIDE       :: 331;
    KEY_KP_MULTIPLY     :: 332;
    KEY_KP_SUBTRACT     :: 333;
    KEY_KP_ADD          :: 334;
    KEY_KP_ENTER        :: 335;
    KEY_KP_EQUAL        :: 336;
    // Android key buttons
    KEY_BACK            :: 4;
    KEY_MENU            :: 82;
    KEY_VOLUME_UP       :: 24;
    KEY_VOLUME_DOWN     :: 25;
}

MouseButton :: enum {
    MOUSE_LEFT_BUTTON   :: 0;
    MOUSE_RIGHT_BUTTON  :: 1;
    MOUSE_MIDDLE_BUTTON :: 2;
}

MouseCursor :: enum {
    MOUSE_CURSOR_DEFAULT       :: 0;
    MOUSE_CURSOR_ARROW         :: 1;
    MOUSE_CURSOR_IBEAM         :: 2;
    MOUSE_CURSOR_CROSSHAIR     :: 3;
    MOUSE_CURSOR_POINTING_HAND :: 4;
    MOUSE_CURSOR_RESIZE_EW     :: 5;     // The horizontal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NS     :: 6;     // The vertical resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NWSE   :: 7;     // The top-left to bottom-right diagonal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_NESW   :: 8;     // The top-right to bottom-left diagonal resize/move arrow shape
    MOUSE_CURSOR_RESIZE_ALL    :: 9;     // The omni-directional resize/move cursor shape
    MOUSE_CURSOR_NOT_ALLOWED   :: 10;
}

GamepadButton :: enum {
    // This is here just for error checking
    GAMEPAD_BUTTON_UNKNOWN :: 0;

    // This is normally a DPAD
    GAMEPAD_BUTTON_LEFT_FACE_UP;
    GAMEPAD_BUTTON_LEFT_FACE_RIGHT;
    GAMEPAD_BUTTON_LEFT_FACE_DOWN;
    GAMEPAD_BUTTON_LEFT_FACE_LEFT;

    // This normally corresponds with PlayStation and Xbox controllers
    // XBOX: [Y;X;A;B]
    // PS3: [Triangle;Square;Cross;Circle]
    // No support for 6 button controllers though..
    GAMEPAD_BUTTON_RIGHT_FACE_UP;
    GAMEPAD_BUTTON_RIGHT_FACE_RIGHT;
    GAMEPAD_BUTTON_RIGHT_FACE_DOWN;
    GAMEPAD_BUTTON_RIGHT_FACE_LEFT;

    // Triggers
    GAMEPAD_BUTTON_LEFT_TRIGGER_1;
    GAMEPAD_BUTTON_LEFT_TRIGGER_2;
    GAMEPAD_BUTTON_RIGHT_TRIGGER_1;
    GAMEPAD_BUTTON_RIGHT_TRIGGER_2;

    // These are buttons in the center of the gamepad
    GAMEPAD_BUTTON_MIDDLE_LEFT;     // PS3 Select
    GAMEPAD_BUTTON_MIDDLE;          // PS Button/XBOX Button
    GAMEPAD_BUTTON_MIDDLE_RIGHT;    // PS3 Start

    // These are the joystick press in buttons
    GAMEPAD_BUTTON_LEFT_THUMB;
    GAMEPAD_BUTTON_RIGHT_THUMB;
}

GamepadAxis :: enum {
    // Left stick
    GAMEPAD_AXIS_LEFT_X :: 0;
    GAMEPAD_AXIS_LEFT_Y :: 1;

    // Right stick
    GAMEPAD_AXIS_RIGHT_X :: 2;
    GAMEPAD_AXIS_RIGHT_Y :: 3;

    // Pressure levels for the back triggers
    GAMEPAD_AXIS_LEFT_TRIGGER :: 4;      // [1..-1] (pressure-level)
    GAMEPAD_AXIS_RIGHT_TRIGGER :: 5;
}

MaterialMapIndex :: enum {
    MATERIAL_MAP_ALBEDO    :: 0;       // MATERIAL_MAP_DIFFUSE
    MATERIAL_MAP_METALNESS :: 1;       // MATERIAL_MAP_SPECULAR
    MATERIAL_MAP_NORMAL    :: 2;
    MATERIAL_MAP_ROUGHNESS :: 3;
    MATERIAL_MAP_OCCLUSION;
    MATERIAL_MAP_EMISSION;
    MATERIAL_MAP_HEIGHT;
    MATERIAL_MAP_BRDG;
    MATERIAL_MAP_CUBEMAP;             // NOTE: Uses GL_TEXTURE_CUBE_MAP
    MATERIAL_MAP_IRRADIANCE;          // NOTE: Uses GL_TEXTURE_CUBE_MAP
    MATERIAL_MAP_PREFILTER;
}

ShaderLocationIndex :: enum {
    SHADER_LOC_VERTEX_POSITION :: 0;
    SHADER_LOC_VERTEX_TEXCOORD01;
    SHADER_LOC_VERTEX_TEXCOORD02;
    SHADER_LOC_VERTEX_NORMAL;
    SHADER_LOC_VERTEX_TANGENT;
    SHADER_LOC_VERTEX_COLOR;
    SHADER_LOC_MATRIX_MVP;
    SHADER_LOC_MATRIX_VIEW;
    SHADER_LOC_MATRIX_PROJECTION;
    SHADER_LOC_MATRIX_MODEL;
    SHADER_LOC_MATRIX_NORMAL;
    SHADER_LOC_VECTOR_VIEW;
    SHADER_LOC_COLOR_DIFFUSE;
    SHADER_LOC_COLOR_SPECULAR;
    SHADER_LOC_COLOR_AMBIENT;
    SHADER_LOC_MAP_ALBEDO;          // SHADER_LOC_MAP_DIFFUSE
    SHADER_LOC_MAP_METALNESS;       // SHADER_LOC_MAP_SPECULAR
    SHADER_LOC_MAP_NORMAL;
    SHADER_LOC_MAP_ROUGHNESS;
    SHADER_LOC_MAP_OCCLUSION;
    SHADER_LOC_MAP_EMISSION;
    SHADER_LOC_MAP_HEIGHT;
    SHADER_LOC_MAP_CUBEMAP;
    SHADER_LOC_MAP_IRRADIANCE;
    SHADER_LOC_MAP_PREFILTER;
    SHADER_LOC_MAP_BRDF;
}

ShaderUniformDataType :: enum {
    SHADER_UNIFORM_FLOAT :: 0;
    SHADER_UNIFORM_VEC2;
    SHADER_UNIFORM_VEC3;
    SHADER_UNIFORM_VEC4;
    SHADER_UNIFORM_INT;
    SHADER_UNIFORM_IVEC2;
    SHADER_UNIFORM_IVEC3;
    SHADER_UNIFORM_IVEC4;
    SHADER_UNIFORM_SAMPLER2D;
}

PixelFormat :: enum {
    PIXELFORMAT_UNCOMPRESSED_GRAYSCALE :: 1;     // 8 bit per pixel (no alpha)
    PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA;        // 8*2 bpp (2 channels)
    PIXELFORMAT_UNCOMPRESSED_R5G6B5;            // 16 bpp
    PIXELFORMAT_UNCOMPRESSED_R8G8B8;            // 24 bpp
    PIXELFORMAT_UNCOMPRESSED_R5G5B5A1;          // 16 bpp (1 bit alpha)
    PIXELFORMAT_UNCOMPRESSED_R4G4B4A4;          // 16 bpp (4 bit alpha)
    PIXELFORMAT_UNCOMPRESSED_R8G8B8A8;          // 32 bpp
    PIXELFORMAT_UNCOMPRESSED_R32;               // 32 bpp (1 channel - float)
    PIXELFORMAT_UNCOMPRESSED_R32G32B32;         // 32*3 bpp (3 channels - float)
    PIXELFORMAT_UNCOMPRESSED_R32G32B32A32;      // 32*4 bpp (4 channels - float)
    PIXELFORMAT_COMPRESSED_DXT1_RGB;            // 4 bpp (no alpha)
    PIXELFORMAT_COMPRESSED_DXT1_RGBA;           // 4 bpp (1 bit alpha)
    PIXELFORMAT_COMPRESSED_DXT3_RGBA;           // 8 bpp
    PIXELFORMAT_COMPRESSED_DXT5_RGBA;           // 8 bpp
    PIXELFORMAT_COMPRESSED_ETC1_RGB;            // 4 bpp
    PIXELFORMAT_COMPRESSED_ETC2_RGB;            // 4 bpp
    PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA;       // 8 bpp
    PIXELFORMAT_COMPRESSED_PVRT_RGB;            // 4 bpp
    PIXELFORMAT_COMPRESSED_PVRT_RGBA;           // 4 bpp
    PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA;       // 8 bpp
    PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA;
}

TextureFilter :: enum {
    TEXTURE_FILTER_POINT :: 0;               // No filter; just pixel aproximation
    TEXTURE_FILTER_BILINEAR;                // Linear filtering
    TEXTURE_FILTER_TRILINEAR;               // Trilinear filtering (linear with mipmaps)
    TEXTURE_FILTER_ANISOTROPIC_4X;          // Anisotropic filtering 4x
    TEXTURE_FILTER_ANISOTROPIC_8X;          // Anisotropic filtering 8x
    TEXTURE_FILTER_ANISOTROPIC_16X;;
}

TextureWrap :: enum {
    TEXTURE_WRAP_REPEAT :: 0;        // Repeats texture in tiled mode
    TEXTURE_WRAP_CLAMP;             // Clamps texture to edge pixel in tiled mode
    TEXTURE_WRAP_MIRROR_REPEAT;     // Mirrors and repeats the texture in tiled mode
    TEXTURE_WRAP_MIRROR_CLAMP;
}

CubemapLayout :: enum {
    CUBEMAP_LAYOUT_AUTO_DETECT :: 0;        // Automatically detect layout type
    CUBEMAP_LAYOUT_LINE_VERTICAL;          // Layout is defined by a vertical line with faces
    CUBEMAP_LAYOUT_LINE_HORIZONTAL;        // Layout is defined by an horizontal line with faces
    CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR;    // Layout is defined by a 3x4 cross with cubemap faces
    CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE;    // Layout is defined by a 4x3 cross with cubemap faces
    CUBEMAP_LAYOUT_PANORAMA;
}

FontType :: enum {
    FONT_DEFAULT :: 0;       // Default font generation; anti-aliased
    FONT_BITMAP;            // Bitmap font generation; no anti-aliasing
    FONT_SDF;
}

BlendMode :: enum {
    BLEND_ALPHA :: 0;        // Blend textures considering alpha (default)
    BLEND_ADDITIVE;         // Blend textures adding colors
    BLEND_MULTIPLIED;       // Blend textures multiplying colors
    BLEND_ADD_COLORS;       // Blend textures adding colors (alternative)
    BLEND_SUBTRACT_COLORS;  // Blend textures subtracting colors (alternative)
    BLEND_CUSTOM;
}

Gestures :: enum {
    GESTURE_NONE        :: 0;
    GESTURE_TAP         :: 1;
    GESTURE_DOUBLETAP   :: 2;
    GESTURE_HOLD        :: 4;
    GESTURE_DRAG        :: 8;
    GESTURE_SWIPE_RIGHT :: 16;
    GESTURE_SWIPE_LEFT  :: 32;
    GESTURE_SWIPE_UP    :: 64;
    GESTURE_SWIPE_DOWN  :: 128;
    GESTURE_PINCH_IN    :: 256;
    GESTURE_PINCH_OUT   :: 512;
}

CameraMode :: enum {
    CAMERA_CUSTOM :: 0;
    CAMERA_FREE;
    CAMERA_ORBITAL;
    CAMERA_FIRST_PERSON;
    CAMERA_THIRD_PERSON;
}

CameraProjection :: enum {
    CAMERA_PERSPECTIVE :: 0;
    CAMERA_ORTHOGRAPHIC;
}

NPatchLayout :: enum {
    NPATCH_NINE_PATCH :: 0;          // Npatch layout: 3x3 tiles
    NPATCH_THREE_PATCH_VERTICAL;    // Npatch layout: 1x3 tiles
    NPATCH_THREE_PATCH_HORIZONTAL;
}

rAudioBuffer :: struct { /* only used as a pointer in this header */ }

Texture2D :: Texture;

TextureCubemap :: Texture;

RenderTexture2D :: RenderTexture;

Camera :: Camera3D;

Color :: struct {
    r: u8;
    g: u8;
    b: u8;
    a: u8;
}

Rectangle :: struct {
    x: float;
    y: float;
    width: float;
    height: float;

    #place x;     position: Vector2;
    #place width; size: Vector2;
}

Image :: struct {
    data: *void;
    width: s32;
    height: s32;
    mipmaps: s32;
    format: s32;
}

Texture :: struct {
    id: u32;
    width: s32;
    height: s32;
    mipmaps: s32;
    format: s32;
}

RenderTexture :: struct {
    id: u32;
    texture: Texture;
    depth: Texture;
}

NPatchInfo :: struct {
    source: Rectangle;
    left: s32;
    top: s32;
    right: s32;
    bottom: s32;
    layout: s32;
}

CharInfo :: struct {
    value: s32;
    offsetX: s32;
    offsetY: s32;
    advanceX: s32;
    image: Image;
}

Font :: struct {
    baseSize: s32;
    charsCount: s32;
    charsPadding: s32;
    texture: Texture2D;
    recs: *Rectangle;
    chars: *CharInfo;
}

Camera3D :: struct {
    position: Vector3;
    target: Vector3;
    up: Vector3;
    fovy: float;
    projection: CameraProjection;
}

Camera2D :: struct {
    offset: Vector2;
    target: Vector2;
    rotation: float;
    zoom: float;
}

Mesh :: struct {
    vertexCount: s32;
    triangleCount: s32;
    vertices: *float;
    texcoords: *float;
    texcoords2: *float;
    normals: *float;
    tangents: *float;
    colors: *u8;
    indices: *u16;
    animVertices: *float;
    animNormals: *float;
    boneIds: *s32;
    boneWeights: *float;
    vaoId: u32;
    vboId: *u32;
}

Shader :: struct {
    id: u32;
    locs: *s32;
}

MaterialMap :: struct {
    texture: Texture2D;
    color: Color;
    value: float;
}

Material :: struct {
    shader: Shader;
    maps: *MaterialMap;
    params: float;
}

Transform :: struct {
    translation: Vector3;
    rotation: Quaternion;
    scale: Vector3;
}

BoneInfo :: struct {
    name: s8;
    parent: s32;
}

Model :: struct {
    transform: Matrix4;
    meshCount: s32;
    materialCount: s32;
    meshes: *Mesh;
    materials: *Material;
    meshMaterial: *s32;
    boneCount: s32;
    bones: *BoneInfo;
    bindPose: *Transform;
}

ModelAnimation :: struct {
    boneCount: s32;
    frameCount: s32;
    bones: *BoneInfo;
    framePoses: **Transform;
}

Ray :: struct {
    position: Vector3;
    direction: Vector3;
}

RayHitInfo :: struct {
    hit: bool;
    distance: float;
    position: Vector3;
    normal: Vector3;
}

BoundingBox :: struct {
    min: Vector3;
    max: Vector3;
}

Wave :: struct {
    sampleCount: u32;
    sampleRate: u32;
    sampleSize: u32;
    channels: u32;
    data: *void;
}

AudioStream :: struct {
    buffer: *rAudioBuffer;
    sampleRate: u32;
    sampleSize: u32;
    channels: u32;
}

Sound :: struct {
    stream: AudioStream;
    sampleCount: u32;
}

Music :: struct {
    stream: AudioStream;
    sampleCount: u32;
    looping: bool;
    ctxType: s32;
    ctxData: *void;
}

VrDeviceInfo :: struct {
    hResolution: s32;
    vResolution: s32;
    hScreenSize: float;
    vScreenSize: float;
    vScreenCenter: float;
    eyeToScreenDistance: float;
    lensSeparationDistance: float;
    interpupillaryDistance: float;
    lensDistortionValues: float;
    chromaAbCorrection: float;
}

VrStereoConfig :: struct {
    projection: Matrix4;
    viewOffset: Matrix4;
    leftLensCenter: float;
    rightLensCenter: float;
    leftScreenCenter: float;
    rightScreenCenter: float;
    scale: float;
    scaleIn: float;
}

InitWindow :: (width: s32, height: s32, title: *u8)  #foreign raylib_native;
WindowShouldClose :: () -> bool #foreign raylib_native;
CloseWindow :: ()  #foreign raylib_native;
IsWindowReady :: () -> bool #foreign raylib_native;
IsWindowFullscreen :: () -> bool #foreign raylib_native;
IsWindowHidden :: () -> bool #foreign raylib_native;
IsWindowMinimized :: () -> bool #foreign raylib_native;
IsWindowMaximized :: () -> bool #foreign raylib_native;
IsWindowFocused :: () -> bool #foreign raylib_native;
IsWindowResized :: () -> bool #foreign raylib_native;
IsWindowState :: (flag: u32) -> bool #foreign raylib_native;
SetWindowState :: (flags: u32)  #foreign raylib_native;
ClearWindowState :: (flags: u32)  #foreign raylib_native;
ToggleFullscreen :: ()  #foreign raylib_native;
MaximizeWindow :: ()  #foreign raylib_native;
MinimizeWindow :: ()  #foreign raylib_native;
RestoreWindow :: ()  #foreign raylib_native;
SetWindowIcon :: (image: Image)  #foreign raylib_native;
SetWindowTitle :: (title: *u8)  #foreign raylib_native;
SetWindowPosition :: (x: s32, y: s32)  #foreign raylib_native;
SetWindowMonitor :: (monitor: s32)  #foreign raylib_native;
SetWindowMinSize :: (width: s32, height: s32)  #foreign raylib_native;
SetWindowSize :: (width: s32, height: s32)  #foreign raylib_native;
GetWindowHandle :: () -> *void #foreign raylib_native;
GetScreenWidth :: () -> s32 #foreign raylib_native;
GetScreenHeight :: () -> s32 #foreign raylib_native;
GetMonitorCount :: () -> s32 #foreign raylib_native;
GetCurrentMonitor :: () -> s32 #foreign raylib_native;
GetMonitorPosition :: (monitor: s32) -> Vector2 #foreign raylib_native;
GetMonitorWidth :: (monitor: s32) -> s32 #foreign raylib_native;
GetMonitorHeight :: (monitor: s32) -> s32 #foreign raylib_native;
GetMonitorPhysicalWidth :: (monitor: s32) -> s32 #foreign raylib_native;
GetMonitorPhysicalHeight :: (monitor: s32) -> s32 #foreign raylib_native;
GetMonitorRefreshRate :: (monitor: s32) -> s32 #foreign raylib_native;
GetWindowPosition :: () -> Vector2 #foreign raylib_native;
GetWindowScaleDPI :: () -> Vector2 #foreign raylib_native;
GetMonitorName :: (monitor: s32) -> *u8 #foreign raylib_native;
SetClipboardText :: (text: *u8)  #foreign raylib_native;
GetClipboardText :: () -> *u8 #foreign raylib_native;
ShowCursor :: ()  #foreign raylib_native;
HideCursor :: ()  #foreign raylib_native;
IsCursorHidden :: () -> bool #foreign raylib_native;
EnableCursor :: ()  #foreign raylib_native;
DisableCursor :: ()  #foreign raylib_native;
IsCursorOnScreen :: () -> bool #foreign raylib_native;
ClearBackground :: (color: Color)  #foreign raylib_native;
BeginDrawing :: ()  #foreign raylib_native;
EndDrawing :: ()  #foreign raylib_native;
BeginMode2D :: (camera: Camera2D)  #foreign raylib_native;
EndMode2D :: ()  #foreign raylib_native;
BeginMode3D :: (camera: Camera3D)  #foreign raylib_native;
EndMode3D :: ()  #foreign raylib_native;
BeginTextureMode :: (target: RenderTexture2D)  #foreign raylib_native;
EndTextureMode :: ()  #foreign raylib_native;
BeginShaderMode :: (shader: Shader)  #foreign raylib_native;
EndShaderMode :: ()  #foreign raylib_native;
BeginBlendMode :: (mode: s32)  #foreign raylib_native;
EndBlendMode :: ()  #foreign raylib_native;
BeginScissorMode :: (x: s32, y: s32, width: s32, height: s32)  #foreign raylib_native;
EndScissorMode :: ()  #foreign raylib_native;
BeginVrStereoMode :: (config: VrStereoConfig)  #foreign raylib_native;
EndVrStereoMode :: ()  #foreign raylib_native;
LoadVrStereoConfig :: (device: VrDeviceInfo) -> VrStereoConfig #foreign raylib_native;
UnloadVrStereoConfig :: (config: VrStereoConfig)  #foreign raylib_native;
LoadShader :: (vsFileName: *u8, fsFileName: *u8) -> Shader #foreign raylib_native;
LoadShaderFromMemory :: (vsCode: *u8, fsCode: *u8) -> Shader #foreign raylib_native;
GetShaderLocation :: (shader: Shader, uniformName: *u8) -> s32 #foreign raylib_native;
GetShaderLocationAttrib :: (shader: Shader, attribName: *u8) -> s32 #foreign raylib_native;
SetShaderValue :: (shader: Shader, uniformLoc: s32, value: *void, uniformType: ShaderUniformDataType) #foreign raylib_native;
SetShaderValueV :: (shader: Shader, uniformLoc: s32, value: *void, uniformType: ShaderUniformDataType, count: s32) #foreign raylib_native;
SetShaderValueMatrix :: (shader: Shader, locIndex: s32, mat: Matrix4)  #foreign raylib_native;
SetShaderValueTexture :: (shader: Shader, locIndex: s32, texture: Texture2D)  #foreign raylib_native;
UnloadShader :: (shader: Shader)  #foreign raylib_native;
GetMouseRay :: (mousePosition: Vector2, camera: Camera) -> Ray #foreign raylib_native;
GetCameraMatrix :: (camera: Camera) -> Matrix4 #foreign raylib_native;
GetCameraMatrix2D :: (camera: Camera2D) -> Matrix4 #foreign raylib_native;
GetWorldToScreen :: (position: Vector3, camera: Camera) -> Vector2 #foreign raylib_native;
GetWorldToScreenEx :: (position: Vector3, camera: Camera, width: s32, height: s32) -> Vector2 #foreign raylib_native;
GetWorldToScreen2D :: (position: Vector2, camera: Camera2D) -> Vector2 #foreign raylib_native;
GetScreenToWorld2D :: (position: Vector2, camera: Camera2D) -> Vector2 #foreign raylib_native;
SetTargetFPS :: (fps: s32)  #foreign raylib_native;
GetFPS :: () -> s32 #foreign raylib_native;
GetFrameTime :: () -> float #foreign raylib_native;
GetTime :: () -> float64 #foreign raylib_native;
GetRandomValue :: (min: s32, max: s32) -> s32 #foreign raylib_native;
TakeScreenshot :: (fileName: *u8)  #foreign raylib_native;
SetConfigFlags :: (flags: ConfigFlags) #foreign raylib_native;
TraceLog :: (logLevel: s32, text: *u8, args: ..*u8)  #foreign raylib_native;
SetTraceLogLevel :: (logType: TraceLogLevel) #foreign raylib_native;
MemAlloc :: (size: s32) -> *void #foreign raylib_native;
MemRealloc :: (ptr: *void, size: s32) -> *void #foreign raylib_native;
MemFree :: (ptr: *void)  #foreign raylib_native;
SetTraceLogCallback :: (callback: TraceLogCallback)  #foreign raylib_native;
SetLoadFileDataCallback :: (callback: LoadFileDataCallback)  #foreign raylib_native;
SetSaveFileDataCallback :: (callback: SaveFileDataCallback)  #foreign raylib_native;
SetLoadFileTextCallback :: (callback: LoadFileTextCallback)  #foreign raylib_native;
SetSaveFileTextCallback :: (callback: SaveFileTextCallback)  #foreign raylib_native;
LoadFileData :: (fileName: *u8, bytesRead: *u32) -> *u8 #foreign raylib_native;
UnloadFileData :: (data: *u8)  #foreign raylib_native;
SaveFileData :: (fileName: *u8, data: *void, bytesToWrite: u32) -> bool #foreign raylib_native;
LoadFileText :: (fileName: *u8) -> *s8 #foreign raylib_native;
UnloadFileText :: (text: *u8)  #foreign raylib_native;
SaveFileText :: (fileName: *u8, text: *s8) -> bool #foreign raylib_native;
FileExists :: (fileName: *u8) -> bool #foreign raylib_native;
DirectoryExists :: (dirPath: *u8) -> bool #foreign raylib_native;
IsFileExtension :: (fileName: *u8, ext: *u8) -> bool #foreign raylib_native;
GetFileExtension :: (fileName: *u8) -> *u8 #foreign raylib_native;
GetFileName :: (filePath: *u8) -> *u8 #foreign raylib_native;
GetFileNameWithoutExt :: (filePath: *u8) -> *u8 #foreign raylib_native;
GetDirectoryPath :: (filePath: *u8) -> *u8 #foreign raylib_native;
GetPrevDirectoryPath :: (dirPath: *u8) -> *u8 #foreign raylib_native;
GetWorkingDirectory :: () -> *u8 #foreign raylib_native;
GetDirectoryFiles :: (dirPath: *u8, count: *s32) -> **s8 #foreign raylib_native;
ClearDirectoryFiles :: ()  #foreign raylib_native;
ChangeDirectory :: (dir: *u8) -> bool #foreign raylib_native;
IsFileDropped :: () -> bool #foreign raylib_native;
GetDroppedFiles :: (count: *s32) -> **s8 #foreign raylib_native;
ClearDroppedFiles :: ()  #foreign raylib_native;
GetFileModTime :: (fileName: *u8) -> s32 #foreign raylib_native;
CompressData :: (data: *u8, dataLength: s32, compDataLength: *s32) -> *u8 #foreign raylib_native;
DecompressData :: (compData: *u8, compDataLength: s32, dataLength: *s32) -> *u8 #foreign raylib_native;
SaveStorageValue :: (position: u32, value: s32) -> bool #foreign raylib_native;
LoadStorageValue :: (position: u32) -> s32 #foreign raylib_native;
OpenURL :: (url: *u8)  #foreign raylib_native;
IsKeyPressed :: (key: KeyboardKey) -> bool #foreign raylib_native;
IsKeyDown :: (key: KeyboardKey) -> bool #foreign raylib_native;
IsKeyReleased :: (key: KeyboardKey) -> bool #foreign raylib_native;
IsKeyUp :: (key: KeyboardKey) -> bool #foreign raylib_native;
SetExitKey :: (key: KeyboardKey) -> bool #foreign raylib_native;
GetKeyPressed :: () -> s32 #foreign raylib_native;
GetCharPressed :: () -> s32 #foreign raylib_native;
IsGamepadAvailable :: (gamepad: s32) -> bool #foreign raylib_native;
IsGamepadName :: (gamepad: s32, name: *u8) -> bool #foreign raylib_native;
GetGamepadName :: (gamepad: s32) -> *u8 #foreign raylib_native;
IsGamepadButtonPressed :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native;
IsGamepadButtonDown :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native;
IsGamepadButtonReleased :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native;
IsGamepadButtonUp :: (gamepad: int, button: GamepadButton) -> bool #foreign raylib_native;
GetGamepadButtonPressed :: () -> s32 #foreign raylib_native;
GetGamepadAxisCount :: (gamepad: s32) -> s32 #foreign raylib_native;
GetGamepadAxisMovement :: (gamepad: int, axis: GamepadAxis) -> float #foreign raylib_native;
SetGamepadMappings :: (mappings: *u8) -> s32 #foreign raylib_native;
IsMouseButtonPressed :: (button: MouseButton) -> bool #foreign raylib_native;
IsMouseButtonDown :: (button: MouseButton) -> bool #foreign raylib_native;
IsMouseButtonReleased :: (button: MouseButton) -> bool #foreign raylib_native;
IsMouseButtonUp :: (button: MouseButton) -> bool #foreign raylib_native;
GetMouseX :: () -> s32 #foreign raylib_native;
GetMouseY :: () -> s32 #foreign raylib_native;
GetMousePosition :: () -> Vector2 #foreign raylib_native;
SetMousePosition :: (x: s32, y: s32)  #foreign raylib_native;
SetMouseOffset :: (offsetX: s32, offsetY: s32)  #foreign raylib_native;
SetMouseScale :: (scaleX: float, scaleY: float)  #foreign raylib_native;
GetMouseWheelMove :: () -> float #foreign raylib_native;
SetMouseCursor :: (cursor: s32)  #foreign raylib_native;
GetTouchX :: () -> s32 #foreign raylib_native;
GetTouchY :: () -> s32 #foreign raylib_native;
GetTouchPosition :: (index: s32) -> Vector2 #foreign raylib_native;
SetGesturesEnabled :: (flags: u32)  #foreign raylib_native;
IsGestureDetected :: (gesture: s32) -> bool #foreign raylib_native;
GetGestureDetected :: () -> s32 #foreign raylib_native;
GetTouchPointsCount :: () -> s32 #foreign raylib_native;
GetGestureHoldDuration :: () -> float #foreign raylib_native;
GetGestureDragVector :: () -> Vector2 #foreign raylib_native;
GetGestureDragAngle :: () -> float #foreign raylib_native;
GetGesturePinchVector :: () -> Vector2 #foreign raylib_native;
GetGesturePinchAngle :: () -> float #foreign raylib_native;
SetCameraMode :: (camera: Camera, mode: CameraMode) #foreign raylib_native;
UpdateCamera :: (camera: *Camera)  #foreign raylib_native;
SetCameraPanControl :: (keyPan: s32)  #foreign raylib_native;
SetCameraAltControl :: (keyAlt: s32)  #foreign raylib_native;
SetCameraSmoothZoomControl :: (keySmoothZoom: s32)  #foreign raylib_native;
SetCameraMoveControls :: (keyFront: s32, keyBack: s32, keyRight: s32, keyLeft: s32, keyUp: s32, keyDown: s32)  #foreign raylib_native;
SetShapesTexture :: (texture: Texture2D, source: Rectangle)  #foreign raylib_native;
DrawPixel :: (posX: s32, posY: s32, color: Color)  #foreign raylib_native;
DrawPixelV :: (position: Vector2, color: Color)  #foreign raylib_native;
DrawLine :: (startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)  #foreign raylib_native;
DrawLineV :: (startPos: Vector2, endPos: Vector2, color: Color)  #foreign raylib_native;
DrawLineEx :: (startPos: Vector2, endPos: Vector2, thick: float, color: Color)  #foreign raylib_native;
DrawLineBezier :: (startPos: Vector2, endPos: Vector2, thick: float, color: Color)  #foreign raylib_native;
DrawLineBezierQuad :: (startPos: Vector2, endPos: Vector2, controlPos: Vector2, thick: float, color: Color)  #foreign raylib_native;
DrawLineStrip :: (points: *Vector2, pointsCount: s32, color: Color)  #foreign raylib_native;
DrawCircle :: (centerX: s32, centerY: s32, radius: float, color: Color)  #foreign raylib_native;
DrawCircleSector :: (center: Vector2, radius: float, startAngle: float, endAngle: float, segments: s32, color: Color)  #foreign raylib_native;
DrawCircleSectorLines :: (center: Vector2, radius: float, startAngle: float, endAngle: float, segments: s32, color: Color)  #foreign raylib_native;
DrawCircleGradient :: (centerX: s32, centerY: s32, radius: float, color1: Color, color2: Color)  #foreign raylib_native;
DrawCircleV :: (center: Vector2, radius: float, color: Color)  #foreign raylib_native;
DrawCircleLines :: (centerX: s32, centerY: s32, radius: float, color: Color)  #foreign raylib_native;
DrawEllipse :: (centerX: s32, centerY: s32, radiusH: float, radiusV: float, color: Color)  #foreign raylib_native;
DrawEllipseLines :: (centerX: s32, centerY: s32, radiusH: float, radiusV: float, color: Color)  #foreign raylib_native;
DrawRing :: (center: Vector2, innerRadius: float, outerRadius: float, startAngle: float, endAngle: float, segments: s32, color: Color)  #foreign raylib_native;
DrawRingLines :: (center: Vector2, innerRadius: float, outerRadius: float, startAngle: float, endAngle: float, segments: s32, color: Color)  #foreign raylib_native;
DrawRectangle :: (posX: s32, posY: s32, width: s32, height: s32, color: Color)  #foreign raylib_native;
DrawRectangleV :: (position: Vector2, size: Vector2, color: Color)  #foreign raylib_native;
DrawRectangleRec :: (rec: Rectangle, color: Color)  #foreign raylib_native;
DrawRectanglePro :: (rec: Rectangle, origin: Vector2, rotation: float, color: Color)  #foreign raylib_native;
DrawRectangleGradientV :: (posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)  #foreign raylib_native;
DrawRectangleGradientH :: (posX: s32, posY: s32, width: s32, height: s32, color1: Color, color2: Color)  #foreign raylib_native;
DrawRectangleGradientEx :: (rec: Rectangle, col1: Color, col2: Color, col3: Color, col4: Color)  #foreign raylib_native;
DrawRectangleLines :: (posX: s32, posY: s32, width: s32, height: s32, color: Color)  #foreign raylib_native;
DrawRectangleLinesEx :: (rec: Rectangle, lineThick: s32, color: Color)  #foreign raylib_native;
DrawRectangleRounded :: (rec: Rectangle, roundness: float, segments: s32, color: Color)  #foreign raylib_native;
DrawRectangleRoundedLines :: (rec: Rectangle, roundness: float, segments: s32, lineThick: s32, color: Color)  #foreign raylib_native;
DrawTriangle :: (v1: Vector2, v2: Vector2, v3: Vector2, color: Color)  #foreign raylib_native;
DrawTriangleLines :: (v1: Vector2, v2: Vector2, v3: Vector2, color: Color)  #foreign raylib_native;
DrawTriangleFan :: (points: *Vector2, pointsCount: s32, color: Color)  #foreign raylib_native;
DrawTriangleStrip :: (points: *Vector2, pointsCount: s32, color: Color)  #foreign raylib_native;
DrawPoly :: (center: Vector2, sides: s32, radius: float, rotation: float, color: Color)  #foreign raylib_native;
DrawPolyLines :: (center: Vector2, sides: s32, radius: float, rotation: float, color: Color)  #foreign raylib_native;
CheckCollisionRecs :: (rec1: Rectangle, rec2: Rectangle) -> bool #foreign raylib_native;
CheckCollisionCircles :: (center1: Vector2, radius1: float, center2: Vector2, radius2: float) -> bool #foreign raylib_native;
CheckCollisionCircleRec :: (center: Vector2, radius: float, rec: Rectangle) -> bool #foreign raylib_native;
CheckCollisionPointRec :: (point: Vector2, rec: Rectangle) -> bool #foreign raylib_native;
CheckCollisionPointCircle :: (point: Vector2, center: Vector2, radius: float) -> bool #foreign raylib_native;
CheckCollisionPointTriangle :: (point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool #foreign raylib_native;
CheckCollisionLines :: (startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: *Vector2) -> bool #foreign raylib_native;
GetCollisionRec :: (rec1: Rectangle, rec2: Rectangle) -> Rectangle #foreign raylib_native;
LoadImage :: (fileName: *u8) -> Image #foreign raylib_native;
LoadImageRaw :: (fileName: *u8, width: s32, height: s32, format: s32, headerSize: s32) -> Image #foreign raylib_native;
LoadImageAnim :: (fileName: *u8, frames: *s32) -> Image #foreign raylib_native;
LoadImageFromMemory :: (fileType: *u8, fileData: *u8, dataSize: s32) -> Image #foreign raylib_native;
UnloadImage :: (image: Image)  #foreign raylib_native;
ExportImage :: (image: Image, fileName: *u8) -> bool #foreign raylib_native;
ExportImageAsCode :: (image: Image, fileName: *u8) -> bool #foreign raylib_native;
GenImageColor :: (width: s32, height: s32, color: Color) -> Image #foreign raylib_native;
GenImageGradientV :: (width: s32, height: s32, top: Color, bottom: Color) -> Image #foreign raylib_native;
GenImageGradientH :: (width: s32, height: s32, left: Color, right: Color) -> Image #foreign raylib_native;
GenImageGradientRadial :: (width: s32, height: s32, density: float, inner: Color, outer: Color) -> Image #foreign raylib_native;
GenImageChecked :: (width: s32, height: s32, checksX: s32, checksY: s32, col1: Color, col2: Color) -> Image #foreign raylib_native;
GenImageWhiteNoise :: (width: s32, height: s32, factor: float) -> Image #foreign raylib_native;
GenImagePerlinNoise :: (width: s32, height: s32, offsetX: s32, offsetY: s32, scale: float) -> Image #foreign raylib_native;
GenImageCellular :: (width: s32, height: s32, tileSize: s32) -> Image #foreign raylib_native;
ImageCopy :: (image: Image) -> Image #foreign raylib_native;
ImageFromImage :: (image: Image, rec: Rectangle) -> Image #foreign raylib_native;
ImageText :: (text: *u8, fontSize: s32, color: Color) -> Image #foreign raylib_native;
ImageTextEx :: (font: Font, text: *u8, fontSize: float, spacing: float, tint: Color) -> Image #foreign raylib_native;
ImageFormat :: (image: *Image, newFormat: s32)  #foreign raylib_native;
ImageToPOT :: (image: *Image, fill: Color)  #foreign raylib_native;
ImageCrop :: (image: *Image, crop: Rectangle)  #foreign raylib_native;
ImageAlphaCrop :: (image: *Image, threshold: float)  #foreign raylib_native;
ImageAlphaClear :: (image: *Image, color: Color, threshold: float)  #foreign raylib_native;
ImageAlphaMask :: (image: *Image, alphaMask: Image)  #foreign raylib_native;
ImageAlphaPremultiply :: (image: *Image)  #foreign raylib_native;
ImageResize :: (image: *Image, newWidth: s32, newHeight: s32)  #foreign raylib_native;
ImageResizeNN :: (image: *Image, newWidth: s32, newHeight: s32)  #foreign raylib_native;
ImageResizeCanvas :: (image: *Image, newWidth: s32, newHeight: s32, offsetX: s32, offsetY: s32, fill: Color)  #foreign raylib_native;
ImageMipmaps :: (image: *Image)  #foreign raylib_native;
ImageDither :: (image: *Image, rBpp: s32, gBpp: s32, bBpp: s32, aBpp: s32)  #foreign raylib_native;
ImageFlipVertical :: (image: *Image)  #foreign raylib_native;
ImageFlipHorizontal :: (image: *Image)  #foreign raylib_native;
ImageRotateCW :: (image: *Image)  #foreign raylib_native;
ImageRotateCCW :: (image: *Image)  #foreign raylib_native;
ImageColorTint :: (image: *Image, color: Color)  #foreign raylib_native;
ImageColorInvert :: (image: *Image)  #foreign raylib_native;
ImageColorGrayscale :: (image: *Image)  #foreign raylib_native;
ImageColorContrast :: (image: *Image, contrast: float)  #foreign raylib_native;
ImageColorBrightness :: (image: *Image, brightness: s32)  #foreign raylib_native;
ImageColorReplace :: (image: *Image, color: Color, replace: Color)  #foreign raylib_native;
LoadImageColors :: (image: Image) -> *Color #foreign raylib_native;
LoadImagePalette :: (image: Image, maxPaletteSize: s32, colorsCount: *s32) -> *Color #foreign raylib_native;
UnloadImageColors :: (colors: *Color)  #foreign raylib_native;
UnloadImagePalette :: (colors: *Color)  #foreign raylib_native;
GetImageAlphaBorder :: (image: Image, threshold: float) -> Rectangle #foreign raylib_native;
ImageClearBackground :: (dst: *Image, color: Color)  #foreign raylib_native;
ImageDrawPixel :: (dst: *Image, posX: s32, posY: s32, color: Color)  #foreign raylib_native;
ImageDrawPixelV :: (dst: *Image, position: Vector2, color: Color)  #foreign raylib_native;
ImageDrawLine :: (dst: *Image, startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color)  #foreign raylib_native;
ImageDrawLineV :: (dst: *Image, start: Vector2, end: Vector2, color: Color)  #foreign raylib_native;
ImageDrawCircle :: (dst: *Image, centerX: s32, centerY: s32, radius: s32, color: Color)  #foreign raylib_native;
ImageDrawCircleV :: (dst: *Image, center: Vector2, radius: s32, color: Color)  #foreign raylib_native;
ImageDrawRectangle :: (dst: *Image, posX: s32, posY: s32, width: s32, height: s32, color: Color)  #foreign raylib_native;
ImageDrawRectangleV :: (dst: *Image, position: Vector2, size: Vector2, color: Color)  #foreign raylib_native;
ImageDrawRectangleRec :: (dst: *Image, rec: Rectangle, color: Color)  #foreign raylib_native;
ImageDrawRectangleLines :: (dst: *Image, rec: Rectangle, thick: s32, color: Color)  #foreign raylib_native;
ImageDraw :: (dst: *Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color)  #foreign raylib_native;
ImageDrawText :: (dst: *Image, text: *u8, posX: s32, posY: s32, fontSize: s32, color: Color)  #foreign raylib_native;
ImageDrawTextEx :: (dst: *Image, font: Font, text: *u8, position: Vector2, fontSize: float, spacing: float, tint: Color)  #foreign raylib_native;
LoadTexture :: (fileName: *u8) -> Texture2D #foreign raylib_native;
LoadTextureFromImage :: (image: Image) -> Texture2D #foreign raylib_native;
LoadTextureCubemap :: (image: Image, layout: s32) -> TextureCubemap #foreign raylib_native;
LoadRenderTexture :: (width: s32, height: s32) -> RenderTexture2D #foreign raylib_native;
UnloadTexture :: (texture: Texture2D)  #foreign raylib_native;
UnloadRenderTexture :: (target: RenderTexture2D)  #foreign raylib_native;
UpdateTexture :: (texture: Texture2D, pixels: *void)  #foreign raylib_native;
UpdateTextureRec :: (texture: Texture2D, rec: Rectangle, pixels: *void)  #foreign raylib_native;
GetTextureData :: (texture: Texture2D) -> Image #foreign raylib_native;
GetScreenData :: () -> Image #foreign raylib_native;
GenTextureMipmaps :: (texture: *Texture2D)  #foreign raylib_native;
SetTextureFilter :: (texture: Texture2D, filter: s32)  #foreign raylib_native;
SetTextureWrap :: (texture: Texture2D, wrap: s32)  #foreign raylib_native;
DrawTexture :: (texture: Texture2D, posX: s32, posY: s32, tint: Color)  #foreign raylib_native;
DrawTextureV :: (texture: Texture2D, position: Vector2, tint: Color)  #foreign raylib_native;
DrawTextureEx :: (texture: Texture2D, position: Vector2, rotation: float, scale: float, tint: Color)  #foreign raylib_native;
DrawTextureRec :: (texture: Texture2D, source: Rectangle, position: Vector2, tint: Color)  #foreign raylib_native;
DrawTextureQuad :: (texture: Texture2D, tiling: Vector2, offset: Vector2, quad: Rectangle, tint: Color)  #foreign raylib_native;
DrawTextureTiled :: (texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: float, scale: float, tint: Color)  #foreign raylib_native;
DrawTexturePro :: (texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: float, tint: Color)  #foreign raylib_native;
DrawTextureNPatch :: (texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: float, tint: Color)  #foreign raylib_native;
DrawTexturePoly :: (texture: Texture2D, center: Vector2, points: *Vector2, texcoords: *Vector2, pointsCount: s32, tint: Color)  #foreign raylib_native;
Fade :: (color: Color, alpha: float) -> Color #foreign raylib_native;
ColorToInt :: (color: Color) -> s32 #foreign raylib_native;
ColorNormalize :: (color: Color) -> Vector4 #foreign raylib_native;
ColorFromNormalized :: (normalized: Vector4) -> Color #foreign raylib_native;
ColorToHSV :: (color: Color) -> Vector3 #foreign raylib_native;
ColorFromHSV :: (hue: float, saturation: float, value: float) -> Color #foreign raylib_native;
ColorAlpha :: (color: Color, alpha: float) -> Color #foreign raylib_native;
ColorAlphaBlend :: (dst: Color, src: Color, tint: Color) -> Color #foreign raylib_native;
GetColor :: (hexValue: s32) -> Color #foreign raylib_native;
GetPixelColor :: (srcPtr: *void, format: s32) -> Color #foreign raylib_native;
SetPixelColor :: (dstPtr: *void, color: Color, format: s32)  #foreign raylib_native;
GetPixelDataSize :: (width: s32, height: s32, format: s32) -> s32 #foreign raylib_native;
GetFontDefault :: () -> Font #foreign raylib_native;
LoadFont :: (fileName: *u8) -> Font #foreign raylib_native;
LoadFontEx :: (fileName: *u8, fontSize: s32, fontChars: *s32, charsCount: s32) -> Font #foreign raylib_native;
LoadFontFromImage :: (image: Image, key: Color, firstChar: s32) -> Font #foreign raylib_native;
LoadFontFromMemory :: (fileType: *u8, fileData: *u8, dataSize: s32, fontSize: s32, fontChars: *s32, charsCount: s32) -> Font #foreign raylib_native;
LoadFontData :: (fileData: *u8, dataSize: s32, fontSize: s32, fontChars: *s32, charsCount: s32, type: s32) -> *CharInfo #foreign raylib_native;
GenImageFontAtlas :: (chars: *CharInfo, recs: **Rectangle, charsCount: s32, fontSize: s32, padding: s32, packMethod: s32) -> Image #foreign raylib_native;
UnloadFontData :: (chars: *CharInfo, charsCount: s32)  #foreign raylib_native;
UnloadFont :: (font: Font)  #foreign raylib_native;
DrawFPS :: (posX: s32, posY: s32)  #foreign raylib_native;
DrawText :: (text: *u8, posX: s32, posY: s32, fontSize: s32, color: Color)  #foreign raylib_native;
DrawTextEx :: (font: Font, text: *u8, position: Vector2, fontSize: float, spacing: float, tint: Color)  #foreign raylib_native;
DrawTextRec :: (font: Font, text: *u8, rec: Rectangle, fontSize: float, spacing: float, wordWrap: bool, tint: Color)  #foreign raylib_native;
DrawTextRecEx :: (font: Font, text: *u8, rec: Rectangle, fontSize: float, spacing: float, wordWrap: bool, tint: Color, selectStart: s32, selectLength: s32, selectTint: Color, selectBackTint: Color)  #foreign raylib_native;
DrawTextCodepoint :: (font: Font, codepoint: s32, position: Vector2, fontSize: float, tint: Color)  #foreign raylib_native;
MeasureText :: (text: *u8, fontSize: s32) -> s32 #foreign raylib_native;
MeasureTextEx :: (font: Font, text: *u8, fontSize: float, spacing: float) -> Vector2 #foreign raylib_native;
GetGlyphIndex :: (font: Font, codepoint: s32) -> s32 #foreign raylib_native;
TextCopy :: (dst: *s8, src: *u8) -> s32 #foreign raylib_native;
TextIsEqual :: (text1: *u8, text2: *u8) -> bool #foreign raylib_native;
TextLength :: (text: *u8) -> u32 #foreign raylib_native;
TextFormat :: (text: *u8, args: ..*u8) -> *u8 #foreign raylib_native;
TextSubtext :: (text: *u8, position: s32, length: s32) -> *u8 #foreign raylib_native;
TextReplace :: (text: *s8, replace: *u8, by: *u8) -> *s8 #foreign raylib_native;
TextInsert :: (text: *u8, insert: *u8, position: s32) -> *s8 #foreign raylib_native;
TextJoin :: (textList: **u8, count: s32, delimiter: *u8) -> *u8 #foreign raylib_native;
TextSplit :: (text: *u8, delimiter: s8, count: *s32) -> **u8 #foreign raylib_native;
TextAppend :: (text: *s8, append: *u8, position: *s32)  #foreign raylib_native;
TextFindIndex :: (text: *u8, find: *u8) -> s32 #foreign raylib_native;
TextToUpper :: (text: *u8) -> *u8 #foreign raylib_native;
TextToLower :: (text: *u8) -> *u8 #foreign raylib_native;
TextToPascal :: (text: *u8) -> *u8 #foreign raylib_native;
TextToInteger :: (text: *u8) -> s32 #foreign raylib_native;
TextToUtf8 :: (codepoints: *s32, length: s32) -> *s8 #foreign raylib_native;
GetCodepoints :: (text: *u8, count: *s32) -> *s32 #foreign raylib_native;
GetCodepointsCount :: (text: *u8) -> s32 #foreign raylib_native;
GetNextCodepoint :: (text: *u8, bytesProcessed: *s32) -> s32 #foreign raylib_native;
CodepointToUtf8 :: (codepoint: s32, byteLength: *s32) -> *u8 #foreign raylib_native;
DrawLine3D :: (startPos: Vector3, endPos: Vector3, color: Color)  #foreign raylib_native;
DrawPoint3D :: (position: Vector3, color: Color)  #foreign raylib_native;
DrawCircle3D :: (center: Vector3, radius: float, rotationAxis: Vector3, rotationAngle: float, color: Color)  #foreign raylib_native;
DrawTriangle3D :: (v1: Vector3, v2: Vector3, v3: Vector3, color: Color)  #foreign raylib_native;
DrawTriangleStrip3D :: (points: *Vector3, pointsCount: s32, color: Color)  #foreign raylib_native;
DrawCube :: (position: Vector3, width: float, height: float, length: float, color: Color)  #foreign raylib_native;
DrawCubeV :: (position: Vector3, size: Vector3, color: Color)  #foreign raylib_native;
DrawCubeWires :: (position: Vector3, width: float, height: float, length: float, color: Color)  #foreign raylib_native;
DrawCubeWiresV :: (position: Vector3, size: Vector3, color: Color)  #foreign raylib_native;
DrawCubeTexture :: (texture: Texture2D, position: Vector3, width: float, height: float, length: float, color: Color)  #foreign raylib_native;
DrawSphere :: (centerPos: Vector3, radius: float, color: Color)  #foreign raylib_native;
DrawSphereEx :: (centerPos: Vector3, radius: float, rings: s32, slices: s32, color: Color)  #foreign raylib_native;
DrawSphereWires :: (centerPos: Vector3, radius: float, rings: s32, slices: s32, color: Color)  #foreign raylib_native;
DrawCylinder :: (position: Vector3, radiusTop: float, radiusBottom: float, height: float, slices: s32, color: Color)  #foreign raylib_native;
DrawCylinderWires :: (position: Vector3, radiusTop: float, radiusBottom: float, height: float, slices: s32, color: Color)  #foreign raylib_native;
DrawPlane :: (centerPos: Vector3, size: Vector2, color: Color)  #foreign raylib_native;
DrawRay :: (ray: Ray, color: Color)  #foreign raylib_native;
DrawGrid :: (slices: s32, spacing: float)  #foreign raylib_native;
LoadModel :: (fileName: *u8) -> Model #foreign raylib_native;
LoadModelFromMesh :: (mesh: Mesh) -> Model #foreign raylib_native;
UnloadModel :: (model: Model)  #foreign raylib_native;
UnloadModelKeepMeshes :: (model: Model)  #foreign raylib_native;
UploadMesh :: (mesh: *Mesh, dynamic: bool)  #foreign raylib_native;
UpdateMeshBuffer :: (mesh: Mesh, index: s32, data: *void, dataSize: s32, offset: s32)  #foreign raylib_native;
DrawMesh :: (mesh: Mesh, material: Material, transform: Matrix4)  #foreign raylib_native;
DrawMeshInstanced :: (mesh: Mesh, material: Material, transforms: *Matrix4, instances: s32)  #foreign raylib_native;
UnloadMesh :: (mesh: Mesh)  #foreign raylib_native;
ExportMesh :: (mesh: Mesh, fileName: *u8) -> bool #foreign raylib_native;
LoadMaterials :: (fileName: *u8, materialCount: *s32) -> *Material #foreign raylib_native;
LoadMaterialDefault :: () -> Material #foreign raylib_native;
UnloadMaterial :: (material: Material)  #foreign raylib_native;
SetMaterialTexture :: (material: *Material, mapType: s32, texture: Texture2D)  #foreign raylib_native;
SetModelMeshMaterial :: (model: *Model, meshId: s32, materialId: s32)  #foreign raylib_native;
LoadModelAnimations :: (fileName: *u8, animsCount: *s32) -> *ModelAnimation #foreign raylib_native;
UpdateModelAnimation :: (model: Model, anim: ModelAnimation, frame: s32)  #foreign raylib_native;
UnloadModelAnimation :: (anim: ModelAnimation)  #foreign raylib_native;
UnloadModelAnimations :: (animations: *ModelAnimation, count: u32)  #foreign raylib_native;
IsModelAnimationValid :: (model: Model, anim: ModelAnimation) -> bool #foreign raylib_native;
GenMeshPoly :: (sides: s32, radius: float) -> Mesh #foreign raylib_native;
GenMeshPlane :: (width: float, length: float, resX: s32, resZ: s32) -> Mesh #foreign raylib_native;
GenMeshCube :: (width: float, height: float, length: float) -> Mesh #foreign raylib_native;
GenMeshSphere :: (radius: float, rings: s32, slices: s32) -> Mesh #foreign raylib_native;
GenMeshHemiSphere :: (radius: float, rings: s32, slices: s32) -> Mesh #foreign raylib_native;
GenMeshCylinder :: (radius: float, height: float, slices: s32) -> Mesh #foreign raylib_native;
GenMeshTorus :: (radius: float, size: float, radSeg: s32, sides: s32) -> Mesh #foreign raylib_native;
GenMeshKnot :: (radius: float, size: float, radSeg: s32, sides: s32) -> Mesh #foreign raylib_native;
GenMeshHeightmap :: (heightmap: Image, size: Vector3) -> Mesh #foreign raylib_native;
GenMeshCubicmap :: (cubicmap: Image, cubeSize: Vector3) -> Mesh #foreign raylib_native;
MeshBoundingBox :: (mesh: Mesh) -> BoundingBox #foreign raylib_native;
MeshTangents :: (mesh: *Mesh)  #foreign raylib_native;
MeshBinormals :: (mesh: *Mesh)  #foreign raylib_native;
DrawModel :: (model: Model, position: Vector3, scale: float, tint: Color)  #foreign raylib_native;
DrawModelEx :: (model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float, scale: Vector3, tint: Color)  #foreign raylib_native;
DrawModelWires :: (model: Model, position: Vector3, scale: float, tint: Color)  #foreign raylib_native;
DrawModelWiresEx :: (model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: float, scale: Vector3, tint: Color)  #foreign raylib_native;
DrawBoundingBox :: (box: BoundingBox, color: Color)  #foreign raylib_native;
DrawBillboard :: (camera: Camera, texture: Texture2D, center: Vector3, size: float, tint: Color)  #foreign raylib_native;
DrawBillboardRec :: (camera: Camera, texture: Texture2D, source: Rectangle, center: Vector3, size: float, tint: Color)  #foreign raylib_native;
CheckCollisionSpheres :: (center1: Vector3, radius1: float, center2: Vector3, radius2: float) -> bool #foreign raylib_native;
CheckCollisionBoxes :: (box1: BoundingBox, box2: BoundingBox) -> bool #foreign raylib_native;
CheckCollisionBoxSphere :: (box: BoundingBox, center: Vector3, radius: float) -> bool #foreign raylib_native;
CheckCollisionRaySphere :: (ray: Ray, center: Vector3, radius: float) -> bool #foreign raylib_native;
CheckCollisionRaySphereEx :: (ray: Ray, center: Vector3, radius: float, collisionPoint: *Vector3) -> bool #foreign raylib_native;
CheckCollisionRayBox :: (ray: Ray, box: BoundingBox) -> bool #foreign raylib_native;
GetCollisionRayMesh :: (ray: Ray, mesh: Mesh, transform: Matrix4) -> RayHitInfo #foreign raylib_native;
GetCollisionRayModel :: (ray: Ray, model: Model) -> RayHitInfo #foreign raylib_native;
GetCollisionRayTriangle :: (ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayHitInfo #foreign raylib_native;
GetCollisionRayGround :: (ray: Ray, groundHeight: float) -> RayHitInfo #foreign raylib_native;
InitAudioDevice :: ()  #foreign raylib_native;
CloseAudioDevice :: ()  #foreign raylib_native;
IsAudioDeviceReady :: () -> bool #foreign raylib_native;
SetMasterVolume :: (volume: float)  #foreign raylib_native;
LoadWave :: (fileName: *u8) -> Wave #foreign raylib_native;
LoadWaveFromMemory :: (fileType: *u8, fileData: *u8, dataSize: s32) -> Wave #foreign raylib_native;
LoadSound :: (fileName: *u8) -> Sound #foreign raylib_native;
LoadSoundFromWave :: (wave: Wave) -> Sound #foreign raylib_native;
UpdateSound :: (sound: Sound, data: *void, samplesCount: s32)  #foreign raylib_native;
UnloadWave :: (wave: Wave)  #foreign raylib_native;
UnloadSound :: (sound: Sound)  #foreign raylib_native;
ExportWave :: (wave: Wave, fileName: *u8) -> bool #foreign raylib_native;
ExportWaveAsCode :: (wave: Wave, fileName: *u8) -> bool #foreign raylib_native;
PlaySound :: (sound: Sound)  #foreign raylib_native;
StopSound :: (sound: Sound)  #foreign raylib_native;
PauseSound :: (sound: Sound)  #foreign raylib_native;
ResumeSound :: (sound: Sound)  #foreign raylib_native;
PlaySoundMulti :: (sound: Sound)  #foreign raylib_native;
StopSoundMulti :: ()  #foreign raylib_native;
GetSoundsPlaying :: () -> s32 #foreign raylib_native;
IsSoundPlaying :: (sound: Sound) -> bool #foreign raylib_native;
SetSoundVolume :: (sound: Sound, volume: float)  #foreign raylib_native;
SetSoundPitch :: (sound: Sound, pitch: float)  #foreign raylib_native;
WaveFormat :: (wave: *Wave, sampleRate: s32, sampleSize: s32, channels: s32)  #foreign raylib_native;
WaveCopy :: (wave: Wave) -> Wave #foreign raylib_native;
WaveCrop :: (wave: *Wave, initSample: s32, finalSample: s32)  #foreign raylib_native;
LoadWaveSamples :: (wave: Wave) -> *float #foreign raylib_native;
UnloadWaveSamples :: (samples: *float)  #foreign raylib_native;
LoadMusicStream :: (fileName: *u8) -> Music #foreign raylib_native;
LoadMusicStreamFromMemory :: (fileType: *u8, data: *u8, dataSize: s32) -> Music #foreign raylib_native;
UnloadMusicStream :: (music: Music)  #foreign raylib_native;
PlayMusicStream :: (music: Music)  #foreign raylib_native;
IsMusicPlaying :: (music: Music) -> bool #foreign raylib_native;
UpdateMusicStream :: (music: Music)  #foreign raylib_native;
StopMusicStream :: (music: Music)  #foreign raylib_native;
PauseMusicStream :: (music: Music)  #foreign raylib_native;
ResumeMusicStream :: (music: Music)  #foreign raylib_native;
SetMusicVolume :: (music: Music, volume: float)  #foreign raylib_native;
SetMusicPitch :: (music: Music, pitch: float)  #foreign raylib_native;
GetMusicTimeLength :: (music: Music) -> float #foreign raylib_native;
GetMusicTimePlayed :: (music: Music) -> float #foreign raylib_native;
InitAudioStream :: (sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream #foreign raylib_native;
UpdateAudioStream :: (stream: AudioStream, data: *void, samplesCount: s32)  #foreign raylib_native;
CloseAudioStream :: (stream: AudioStream)  #foreign raylib_native;
IsAudioStreamProcessed :: (stream: AudioStream) -> bool #foreign raylib_native;
PlayAudioStream :: (stream: AudioStream)  #foreign raylib_native;
PauseAudioStream :: (stream: AudioStream)  #foreign raylib_native;
ResumeAudioStream :: (stream: AudioStream)  #foreign raylib_native;
IsAudioStreamPlaying :: (stream: AudioStream) -> bool #foreign raylib_native;
StopAudioStream :: (stream: AudioStream)  #foreign raylib_native;
SetAudioStreamVolume :: (stream: AudioStream, volume: float)  #foreign raylib_native;
SetAudioStreamPitch :: (stream: AudioStream, pitch: float)  #foreign raylib_native;
SetAudioStreamBufferSizeDefault :: (size: s32)  #foreign raylib_native;


float16 :: struct { v: [16]float; }

// TODO: parse rlgl.h and generate rlgl.jai separately
MatrixToFloatV  :: (mat: Matrix4) -> float16 #foreign raylib_native;
MatrixToFloat   :: (mat: Matrix4) -> *float { return MatrixToFloatV(mat).v.data; };
MatrixTranslate :: (x: float, y: float, z: float) -> Matrix4 #foreign raylib_native;
MatrixRotate    :: (axis: Vector3, angle_radians: float) -> Matrix4 #foreign raylib_native;
MatrixScale     :: (x: float, y: float, z: float) -> Matrix4 #foreign raylib_native;
MatrixMultiply  :: (a: Matrix4, b: Matrix4) -> Matrix4 #foreign raylib_native;

DrawText :: inline ($$text: string, posX: s32, posY: s32, fontSize: s32, color: Color) {
    DrawText(constant_or_temp_cstring(text), posX, posY, fontSize, color);
}

make_Rectangle :: (x: $A, y: $B, width: $C, height: $D) -> Rectangle {
    r: Rectangle;
    r.x      = cast(float)x;
    r.y      = cast(float)y;
    r.width  = cast(float)width;
    r.height = cast(float)height;
    return r;
}

make_Color :: (r: $A, g: $B, b: $C, a: $D) -> Color {
    color: Color;
    color.r = cast(u8)r;
    color.g = cast(u8)g;
    color.b = cast(u8)b;
    color.a = cast(u8)a;
    return color;
}

make_Vector3 :: (x: $A, y: $B, z: $C) -> Vector3 {
    v: Vector3;
    v.x = cast(float)x;
    v.y = cast(float)y;
    v.z = cast(float)z;
    return v;
}

make_Vector2 :: (x: $A, y: $B) -> Vector2 {
    v: Vector2;
    v.x = cast(float)x;
    v.y = cast(float)y;
    return v;
}

// Macros for Begin/End pairs where the EndXXX Function is called automatically
// at the end of the scope.

PushDrawing :: () #expand {
    BeginDrawing();
    `defer EndDrawing();
}

PushMode2D :: (camera: Camera2D) #expand {
    BeginMode2D(camera);
    `defer EndMode2D();
}

PushMode3D :: (camera: Camera3D) #expand {
    BeginMode3D(camera);
    `defer EndMode3D();
}

PushTextureMode :: (target: RenderTexture2D) #expand {
    BeginTextureMode(target);
    `defer EndTextureMode();
}

PushScissorMode :: (x: s32, y: s32, width: s32, height: s32) #expand {
    BeginScissorMode(x, y, width, height);
    `defer EndScissorMode();
}

PushShaderMode :: (shader: Shader) #expand {
    BeginShaderMode(shader);
    `defer EndShaderMode();
}

PushBlendMode :: (mode: s32) #expand {
    BeginBlendMode(mode);
    `defer EndBlendMode();
}

#scope_file
Basic :: #import "Basic";

_to_temp_c_string :: (s: string) -> *u8 {
    result : *u8 = Basic.talloc(s.count + 1);
    memcpy(result, s.data, s.count);
    result[s.count] = 0;
    return result;
}

constant_or_temp_cstring :: inline ($$text: string) -> *u8 {
    c_str: *u8;
    #if is_constant(text)
        c_str = text.data;
    else
        c_str = _to_temp_c_string(text);
    return c_str;
}

TraceLogCallback :: #type (logLevel: TraceLogLevel, text: *u8, args: .. Any);
LoadFileDataCallback :: #type (fileName: *u8, bytesRead: *u32) -> *u8;
SaveFileDataCallback :: #type (fileName: *u8, data: *void, bytesToWrite: u32) -> bool;
LoadFileTextCallback :: #type (fileName: *u8) -> *u8;
SaveFileTextCallback :: #type (fileName: *u8, text: *u8) -> bool;



#scope_file // ---------------

#if OS == .WINDOWS {
    #foreign_system_library "user32";
    #foreign_system_library "gdi32";
    #foreign_system_library "shell32";
    #foreign_system_library "winmm";
    raylib_native :: #foreign_library,no_dll "raylib/lib/raylib";
}
#import "Math";
